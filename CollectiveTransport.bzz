
### BUZZ FUNCTIONS ##

# By Aishwary Jagetia
# We need this for 2D vectors
# Make sure you pass the correct include path to "bzzc -I <path1:path2> ..."
include "/usr/local/share/buzz/include/vec2.bzz"

# Scaling factor used for light intensity  
C = 10
# setting a 2D vector from length and angle
function vec2_new_polar(length, angle) {
   vec2 = {}
	 vec2 = { .x = length * math.cos(angle),
            .y = length * math.sin(angle)
	 }
   return vec2
}
 
# Summing two 2D vectors (v1 = v1 + v2)
function vec2_sum(v1, v2) {
   v1.x = v1.x + v2.x
   v1.y = v1.y + v2.y
	 return v1
}
 
# Multiplying two 2D vector with a constant (v1 = v1 * C)
function vec2_multi(v1, C) {
   v1.x = v1.x*C
   v1.y = v1.y*C
	 return v1
}

# Getting the angle of a 2D vector
function vec2_angle(v) {
   return math.atan(v.y, v.x)
}

# Getting the light vector
function goto_light(){
	i = 0
	V = {}
	sum_V = vec2_new_polar(0,0)

	while (i < 8){
	V[i] = vec2_new_polar(light[i].value,light[i].angle)
	sum_V = vec2_sum(V[i],sum_V)
	i = i + 1
	}
	sum_V = vec2_multi(sum_V, C)
	return sum_V
}
  
# Lennard-Jones parameters
# For Square formation 
TARGET_KIN     = 50.0 #d(2)^(1/2)
EPSILON_KIN    = 500.0
TARGET_NONKIN  = 35.0 # d
EPSILON_NONKIN = 500.0
# For Cell formation 
TARGET     = 50.0 # d` =~ d
EPSILON    = 500.0
TARGET_in  = 75.0 # ~1.8*d`
EPSILON_in = 500.0
     
# Lennard-Jones interaction magnitude
function lj_magnitude(dist, target, epsilon) {
  return -(epsilon / dist) * ((target / dist)^4 - (target / dist)^2)
}
     
# Neighbor data to LJ interaction vector
function lj_vector_kin(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET_KIN, EPSILON_KIN), data.azimuth)
}
    
# Neighbor data to LJ interaction vector
function lj_vector_nonkin(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET_NONKIN, EPSILON_NONKIN), data.azimuth)
}
    
# Neighbor data to LJ interaction vector
function lj_vector(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET, EPSILON), data.azimuth)
}

# Neighbor data to LJ interaction vector
function lj_vector_in(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET_in, EPSILON_in), data.azimuth)
}

# Accumulator of neighbor LJ interactions
function lj_sum(rid, data, accum) {
  return math.vec2.add(data, accum)
}
    
# Calculates and actuates the flocking interaction
function square() {
  # Calculate accumulator

	# Setting LEDs for Swarm s1 and s2
	if (s1.in()){
	set_leds(0,0,255)
	}
	
	if (s2.in()){
	set_leds(0,255,0)
	}

	var accum = neighbors.kin().map(lj_vector_kin).reduce(lj_sum, math.vec2.new(0.0, 0.0))
  accum = neighbors.nonkin().map(lj_vector_nonkin).reduce(lj_sum, accum)

	# Adding the light intensity vector to accum
	accum = vec2_sum(accum,goto_light())	

  if(neighbors.count() > 0)
    math.vec2.scale(accum, 1.0 / neighbors.count())
  # Move according to vector
  goto(accum.x, accum.y)
}

# Calculates and actuates the flocking interaction
function cell() {
  # Calculate accumulator
  var accum = neighbors.kin().map(lj_vector).reduce(lj_sum, math.vec2.new(0.0, 0.0))
	
	# Swarm s3 constitutes of robots which are inside the cell
	if (s3.in()){
	set_leds(0,0,255)
	accum = neighbors.nonkin().map(lj_vector).reduce(lj_sum, accum)
	}
	
	# Swarm s4 constitutes of robots which are outside the cell
	if (s4.in()){
	set_leds(255,0,0)
	accum = neighbors.nonkin().map(lj_vector_in).reduce(lj_sum, accum)
	}
	
	# Adding the light intensity vector to accum
	accum = vec2_sum(accum,goto_light())

  if(neighbors.count() > 0)
    math.vec2.scale(accum, 1.0 / neighbors.count())
  # Move according to vector
  goto(accum.x, accum.y)
}

# Executed at init time
function init() {
# Divide the swarm in 4 sub-swarms

	s1 = swarm.create(1)
	s1.select(id < 5)
	
	s2 = swarm.create(2)
	s2.select((id < 9) and (id >= 5))

	s3 = swarm.create(3)
	s3.select(id < 9)

	s4 = s3.others(4)

# Swarm 3 is not required but for implementing cell or square functions independently we need s3

}
   
# Executed every time step
function step() {

		s4.exec(cell)
		s1.exec(square)
  	s2.exec(square)

}

function reset() {
}
     
# Execute at exit
function destroy() {
}

